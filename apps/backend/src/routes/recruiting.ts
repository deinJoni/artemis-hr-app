import type { Hono } from 'hono'
import type { SupabaseClient, User } from '@supabase/supabase-js'

import {
  JobCreateInputSchema,
  JobUpdateInputSchema,
  JobPublishInputSchema,
  JobListResponseSchema,
  JobDetailResponseSchema,
  CandidateCreateInputSchema,
  CandidateListResponseSchema,
  CandidateDetailResponseSchema,
  ApplicationUpdateStageInputSchema,
  InterviewCreateInputSchema,
  InterviewListResponseSchema,
  InterviewDetailResponseSchema,
  EvaluationCreateInputSchema,
  EmailSendInputSchema,
  CommunicationListResponseSchema,
  type JobCreateInput,
  type JobUpdateInput,
  type JobPublishInput,
  type CandidateCreateInput,
  type ApplicationUpdateStageInput,
  type InterviewCreateInput,
  type EvaluationCreateInput,
  type EmailSendInput,
} from '@vibe/shared'

import type { Database } from '@database.types.ts'
import { supabaseAdmin } from '../lib/supabase'
import type { Env } from '../types'

const RESUME_BUCKET = 'candidate-resumes'

const sanitizeStorageFileName = (name: string) => {
  const withoutSeparators = name.replace(/[\\/]+/g, '_').trim()
  const normalized =
    typeof withoutSeparators.normalize === 'function'
      ? withoutSeparators.normalize('NFKD').replace(/[\u0300-\u036f]/g, '')
      : withoutSeparators
  const safe = normalized.replace(/[^a-zA-Z0-9._-]+/g, '_').replace(/_+/g, '_')
  const clipped = safe.slice(-200)
  return clipped.length > 0 ? clipped : 'resume'
}

const buildResumeStoragePath = (tenantId: string, candidateId: string, fileName: string) => {
  const unique =
    typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
      ? crypto.randomUUID()
      : `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`
  return `candidates/${tenantId}/${candidateId}/${unique}-${fileName}`
}

export const registerRecruitingRoutes = (app: Hono<Env>) => {
  // ==============================================
  // JOBS ENDPOINTS
  // ==============================================

  app.post('/api/jobs', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const user = c.get('user') as User
    const body = await c.req.json()

    const input = JobCreateInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: input.data.tenant_id,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    const job = await supabase
      .from('jobs')
      .insert({
        tenant_id: input.data.tenant_id,
        job_id: '', // Will be auto-generated by trigger
        title: input.data.title,
        department_id: input.data.department_id ?? null,
        location_id: input.data.location_id ?? null,
        description: input.data.description,
        requirements: input.data.requirements ?? null,
        employment_type: input.data.employment_type ?? null,
        work_location: input.data.work_location ?? null,
        salary_min: input.data.salary_min ?? null,
        salary_max: input.data.salary_max ?? null,
        salary_currency: input.data.salary_currency ?? null,
        salary_hidden: input.data.salary_hidden ?? false,
        benefits: input.data.benefits ?? null,
        application_deadline: input.data.application_deadline ?? null,
        created_by: user.id,
        status: 'draft',
      })
      .select()
      .single()

    if (job.error) return c.json({ error: job.error.message }, 400)
    return c.json(job.data)
  })

  app.get('/api/jobs', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const user = c.get('user') as User
    const tenantId = c.req.query('tenant_id')
    const status = c.req.query('status')
    const departmentId = c.req.query('department_id')
    const search = c.req.query('search')
    const limit = parseInt(c.req.query('limit') || '50')
    const offset = parseInt(c.req.query('offset') || '0')

    if (!tenantId) return c.json({ error: 'tenant_id is required' }, 400)

    // Check if user is owner first (owners have all permissions)
    const membership = await supabase
      .from('memberships')
      .select('role')
      .eq('user_id', user.id)
      .eq('tenant_id', tenantId)
      .maybeSingle()

    const isOwner = membership.data?.role === 'owner'

    if (!isOwner) {
      const canRead = await supabase.rpc('app_has_permission', {
        permission: 'recruiting.jobs.read',
        tenant: tenantId,
      })
      if (canRead.error) return c.json({ error: canRead.error.message }, 400)
      if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)
    }

    let query = supabase
      .from('jobs')
      .select('*', { count: 'exact' })
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (status) {
      query = query.eq('status', status)
    }
    if (departmentId) {
      query = query.eq('department_id', departmentId)
    }
    if (search) {
      query = query.or(`title.ilike.%${search}%,description.ilike.%${search}%`)
    }

    const result = await query
    if (result.error) return c.json({ error: result.error.message }, 400)

    return c.json({
      jobs: result.data ?? [],
      total: result.count ?? 0,
    })
  })

  app.get('/api/jobs/:tenantId/:id', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.param('tenantId')
    const jobId = c.req.param('id')

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    const [job, postings, applicationCount] = await Promise.all([
      supabase.from('jobs').select('*').eq('tenant_id', tenantId).eq('id', jobId).maybeSingle(),
      supabase.from('job_postings').select('*').eq('job_id', jobId),
      supabase
        .from('applications')
        .select('id', { count: 'exact', head: true })
        .eq('job_id', jobId),
    ])

    if (job.error) return c.json({ error: job.error.message }, 400)
    if (!job.data) return c.json({ error: 'Job not found' }, 404)
    if (postings.error) return c.json({ error: postings.error.message }, 400)
    if (applicationCount.error) return c.json({ error: applicationCount.error.message }, 400)

    // Fetch department and location names
    let departmentName = null
    let locationName = null
    if (job.data.department_id) {
      const dept = await supabase
        .from('departments')
        .select('name')
        .eq('id', job.data.department_id)
        .maybeSingle()
      if (dept.data) departmentName = dept.data.name
    }
    if (job.data.location_id) {
      const loc = await supabase
        .from('office_locations')
        .select('name')
        .eq('id', job.data.location_id)
        .maybeSingle()
      if (loc.data) locationName = loc.data.name
    }

    return c.json({
      ...job.data,
      department_name: departmentName,
      location_name: locationName,
      postings: postings.data ?? [],
      application_count: applicationCount.count ?? 0,
    })
  })

  app.put('/api/jobs/:tenantId/:id', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.param('tenantId')
    const jobId = c.req.param('id')
    const body = await c.req.json()

    const input = JobUpdateInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: tenantId,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    const updateData: any = {}
    if (input.data.title !== undefined) updateData.title = input.data.title
    if (input.data.department_id !== undefined) updateData.department_id = input.data.department_id
    if (input.data.location_id !== undefined) updateData.location_id = input.data.location_id
    if (input.data.status !== undefined) updateData.status = input.data.status
    if (input.data.description !== undefined) updateData.description = input.data.description
    if (input.data.requirements !== undefined) updateData.requirements = input.data.requirements
    if (input.data.employment_type !== undefined) updateData.employment_type = input.data.employment_type
    if (input.data.work_location !== undefined) updateData.work_location = input.data.work_location
    if (input.data.salary_min !== undefined) updateData.salary_min = input.data.salary_min
    if (input.data.salary_max !== undefined) updateData.salary_max = input.data.salary_max
    if (input.data.salary_currency !== undefined) updateData.salary_currency = input.data.salary_currency
    if (input.data.salary_hidden !== undefined) updateData.salary_hidden = input.data.salary_hidden
    if (input.data.benefits !== undefined) updateData.benefits = input.data.benefits
    if (input.data.application_deadline !== undefined)
      updateData.application_deadline = input.data.application_deadline

    const job = await supabase
      .from('jobs')
      .update(updateData)
      .eq('tenant_id', tenantId)
      .eq('id', jobId)
      .select()
      .single()

    if (job.error) return c.json({ error: job.error.message }, 400)
    return c.json(job.data)
  })

  app.post('/api/jobs/:tenantId/:id/publish', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const user = c.get('user') as User
    const tenantId = c.req.param('tenantId')
    const jobId = c.req.param('id')
    const body = await c.req.json()

    const input = JobPublishInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: tenantId,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    // Update job status to active and set published_at
    const job = await supabase
      .from('jobs')
      .update({
        status: 'active',
        published_at: new Date().toISOString(),
        approved_by: user.id,
      })
      .eq('tenant_id', tenantId)
      .eq('id', jobId)
      .select()
      .single()

    if (job.error) return c.json({ error: job.error.message }, 400)

    // Create job postings for selected channels
    const postings = input.data.channels.map((channel) => ({
      job_id: jobId,
      channel,
      budget: input.data.budget?.[channel] ?? null,
      status: 'pending' as const,
    }))

    if (postings.length > 0) {
      const { error } = await supabase.from('job_postings').insert(postings)
      if (error) return c.json({ error: error.message }, 400)
    }

    return c.json({ success: true, job: job.data })
  })

  // ==============================================
  // CANDIDATES ENDPOINTS
  // ==============================================

  app.post('/api/candidates', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const body = await c.req.json()

    const input = CandidateCreateInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.candidates.write',
      tenant: input.data.tenant_id,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    // Check if candidate already exists by email
    const existing = await supabase
      .from('candidates')
      .select('id')
      .eq('tenant_id', input.data.tenant_id)
      .eq('email', input.data.email)
      .maybeSingle()

    let candidateId: string
    if (existing.data) {
      // Update existing candidate
      const update = await supabase
        .from('candidates')
        .update({
          name: input.data.name,
          phone: input.data.phone ?? null,
          resume_url: input.data.resume_url ?? null,
          cover_letter: input.data.cover_letter ?? null,
          linkedin_url: input.data.linkedin_url ?? null,
          portfolio_url: input.data.portfolio_url ?? null,
          source: input.data.source,
          source_details: input.data.source_details ?? null,
        })
        .eq('id', existing.data.id)
        .select()
        .single()

      if (update.error) return c.json({ error: update.error.message }, 400)
      candidateId = update.data.id
    } else {
      // Create new candidate
      const candidate = await supabase
        .from('candidates')
        .insert({
          tenant_id: input.data.tenant_id,
          name: input.data.name,
          email: input.data.email,
          phone: input.data.phone ?? null,
          resume_url: input.data.resume_url ?? null,
          cover_letter: input.data.cover_letter ?? null,
          linkedin_url: input.data.linkedin_url ?? null,
          portfolio_url: input.data.portfolio_url ?? null,
          source: input.data.source,
          source_details: input.data.source_details ?? null,
        })
        .select()
        .single()

      if (candidate.error) return c.json({ error: candidate.error.message }, 400)
      candidateId = candidate.data.id
    }

    // Create or update application
    const application = await supabase
      .from('applications')
      .upsert(
        {
          job_id: input.data.job_id,
          candidate_id: candidateId,
          application_answers: input.data.application_answers ?? null,
          status: 'applied',
        },
        { onConflict: 'job_id,candidate_id' }
      )
      .select()
      .single()

    if (application.error) return c.json({ error: application.error.message }, 400)

    // Get default stage for "applied"
    const stages = await supabase
      .from('pipeline_stages')
      .select('id')
      .eq('job_id', input.data.job_id)
      .eq('stage_type', 'applied')
      .maybeSingle()

    if (stages.data) {
      await supabase
        .from('applications')
        .update({ current_stage_id: stages.data.id })
        .eq('id', application.data.id)
    }

    return c.json({ candidate_id: candidateId, application_id: application.data.id })
  })

  app.get('/api/candidates', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.query('tenant_id')
    const jobId = c.req.query('job_id')
    const status = c.req.query('status')
    const limit = parseInt(c.req.query('limit') || '50')
    const offset = parseInt(c.req.query('offset') || '0')

    if (!tenantId) return c.json({ error: 'tenant_id is required' }, 400)

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.candidates.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    let query = supabase
      .from('candidates')
      .select(
        `
        *,
        applications!inner(
          id,
          status,
          current_stage_id,
          match_score,
          job_id,
          jobs(title)
        )
      `,
        { count: 'exact' }
      )
      .eq('tenant_id', tenantId)
      .order('applied_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (jobId) {
      query = query.eq('applications.job_id', jobId)
    }
    if (status) {
      query = query.eq('applications.status', status)
    }

    const result = await query
    if (result.error) return c.json({ error: result.error.message }, 400)

    // Transform the data
    const candidates = (result.data ?? []).map((candidate: any) => {
      const application = candidate.applications?.[0]
      return {
        ...candidate,
        application_id: application?.id ?? null,
        current_stage: application?.current_stage_id ?? null,
        match_score: application?.match_score ?? null,
        current_job_title: application?.jobs?.title ?? null,
      }
    })

    return c.json({
      candidates,
      total: result.count ?? 0,
    })
  })

  app.get('/api/candidates/:tenantId/:id', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.param('tenantId')
    const candidateId = c.req.param('id')

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.candidates.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    const [candidate, applications] = await Promise.all([
      supabase
        .from('candidates')
        .select('*')
        .eq('tenant_id', tenantId)
        .eq('id', candidateId)
        .maybeSingle(),
      supabase
        .from('applications')
        .select('*, jobs(title, id)')
        .eq('candidate_id', candidateId),
    ])

    if (candidate.error) return c.json({ error: candidate.error.message }, 400)
    if (!candidate.data) return c.json({ error: 'Candidate not found' }, 404)
    if (applications.error) return c.json({ error: applications.error.message }, 400)

    return c.json({
      ...candidate.data,
      applications: (applications.data ?? []).map((app: any) => ({
        ...app,
        job_title: app.jobs?.title ?? null,
        job_id: app.jobs?.id ?? null,
      })),
    })
  })

  app.put('/api/applications/:tenantId/:id/stage', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.param('tenantId')
    const applicationId = c.req.param('id')
    const body = await c.req.json()

    const input = ApplicationUpdateStageInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    // Get application to check tenant
    const application = await supabase
      .from('applications')
      .select('job_id, jobs!inner(tenant_id)')
      .eq('id', applicationId)
      .maybeSingle()

    if (application.error) return c.json({ error: application.error.message }, 400)
    if (!application.data) return c.json({ error: 'Application not found' }, 404)

    const appTenantId = (application.data as any).jobs.tenant_id

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: appTenantId,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    // Get stage to determine status
    const stage = await supabase
      .from('pipeline_stages')
      .select('stage_type')
      .eq('id', input.data.stage_id)
      .maybeSingle()

    if (stage.error) return c.json({ error: stage.error.message }, 400)
    if (!stage.data) return c.json({ error: 'Stage not found' }, 404)

    const statusMap: Record<string, string> = {
      applied: 'applied',
      screening: 'screening',
      interview: 'interview',
      offer: 'offer',
      hired: 'hired',
      rejected: 'rejected',
    }

    const update = await supabase
      .from('applications')
      .update({
        current_stage_id: input.data.stage_id,
        status: statusMap[stage.data.stage_type] || 'applied',
        notes: input.data.notes ?? null,
      })
      .eq('id', applicationId)
      .select()
      .single()

    if (update.error) return c.json({ error: update.error.message }, 400)
    return c.json(update.data)
  })

  // ==============================================
  // INTERVIEWS ENDPOINTS
  // ==============================================

  app.post('/api/interviews', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const body = await c.req.json()

    const input = InterviewCreateInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    // Get application to check permissions
    const application = await supabase
      .from('applications')
      .select('job_id, jobs!inner(tenant_id)')
      .eq('id', input.data.application_id)
      .maybeSingle()

    if (application.error) return c.json({ error: application.error.message }, 400)
    if (!application.data) return c.json({ error: 'Application not found' }, 404)

    const tenantId = (application.data as any).jobs.tenant_id

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: tenantId,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    const interview = await supabase
      .from('interviews')
      .insert({
        application_id: input.data.application_id,
        type: input.data.type,
        scheduled_at: input.data.scheduled_at,
        duration_minutes: input.data.duration_minutes ?? 60,
        location: input.data.location ?? null,
        meeting_link: input.data.meeting_link ?? null,
        interviewer_ids: input.data.interviewer_ids,
        notes: input.data.notes ?? null,
        status: 'scheduled',
      })
      .select()
      .single()

    if (interview.error) return c.json({ error: interview.error.message }, 400)
    return c.json(interview.data)
  })

  app.get('/api/interviews', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.query('tenant_id')
    const applicationId = c.req.query('application_id')
    const limit = parseInt(c.req.query('limit') || '50')
    const offset = parseInt(c.req.query('offset') || '0')

    if (!tenantId) return c.json({ error: 'tenant_id is required' }, 400)

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    let query = supabase
      .from('interviews')
      .select(
        `
        *,
        applications!inner(
          job_id,
          candidate_id,
          jobs!inner(title, tenant_id),
          candidates(name, email)
        )
      `,
        { count: 'exact' }
      )
      .eq('applications.jobs.tenant_id', tenantId)
      .order('scheduled_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (applicationId) {
      query = query.eq('application_id', applicationId)
    }

    const result = await query
    if (result.error) return c.json({ error: result.error.message }, 400)

    // Transform and fetch interviewer details
    const interviews = await Promise.all(
      (result.data ?? []).map(async (interview: any) => {
        const app = interview.applications
        const interviewers = await Promise.all(
          interview.interviewer_ids.map(async (id: string) => {
            const user = await supabaseAdmin.auth.admin.getUserById(id)
            if (user.data.user) {
              return {
                id: user.data.user.id,
                name: user.data.user.user_metadata?.name || user.data.user.email || 'Unknown',
                email: user.data.user.email || '',
              }
            }
            return { id, name: 'Unknown', email: '' }
          })
        )

        return {
          ...interview,
          candidate_name: app.candidates?.name ?? '',
          job_title: app.jobs?.title ?? '',
          interviewers,
        }
      })
    )

    return c.json({
      interviews,
      total: result.count ?? 0,
    })
  })

  app.post('/api/interviews/:id/evaluate', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const user = c.get('user') as User
    const interviewId = c.req.param('id')
    const body = await c.req.json()

    const input = EvaluationCreateInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    // Get interview to check permissions
    const interview = await supabase
      .from('interviews')
      .select('application_id, applications!inner(job_id, jobs!inner(tenant_id))')
      .eq('id', interviewId)
      .maybeSingle()

    if (interview.error) return c.json({ error: interview.error.message }, 400)
    if (!interview.data) return c.json({ error: 'Interview not found' }, 404)

    const tenantId = (interview.data as any).applications.jobs.tenant_id

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: tenantId,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    const evaluation = await supabase
      .from('evaluations')
      .upsert(
        {
          interview_id: interviewId,
          evaluator_id: user.id,
          scores: input.data.scores,
          notes: input.data.notes ?? null,
          overall_rating: input.data.overall_rating ?? null,
          recommendation: input.data.recommendation ?? null,
        },
        { onConflict: 'interview_id,evaluator_id' }
      )
      .select()
      .single()

    if (evaluation.error) return c.json({ error: evaluation.error.message }, 400)
    return c.json(evaluation.data)
  })

  // ==============================================
  // COMMUNICATIONS ENDPOINTS
  // ==============================================

  app.post('/api/communications/email', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const user = c.get('user') as User
    const body = await c.req.json()

    const input = EmailSendInputSchema.safeParse(body)
    if (!input.success) {
      return c.json({ error: 'Invalid input', details: input.error.issues }, 400)
    }

    // Get candidate to check tenant
    const candidate = await supabase
      .from('candidates')
      .select('tenant_id')
      .eq('id', input.data.candidate_id)
      .maybeSingle()

    if (candidate.error) return c.json({ error: candidate.error.message }, 400)
    if (!candidate.data) return c.json({ error: 'Candidate not found' }, 404)

    const canWrite = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.write',
      tenant: candidate.data.tenant_id,
    })
    if (canWrite.error) return c.json({ error: canWrite.error.message }, 400)
    if (!canWrite.data) return c.json({ error: 'Forbidden' }, 403)

    // Store communication (MVP: no actual email sending)
    const communication = await supabase
      .from('communications')
      .insert({
        tenant_id: candidate.data.tenant_id,
        candidate_id: input.data.candidate_id,
        type: 'email',
        direction: 'outbound',
        subject: input.data.subject,
        content: input.data.content,
        template_id: input.data.template_id ?? null,
        sent_at: input.data.scheduled_at ? null : new Date().toISOString(),
        status: input.data.scheduled_at ? 'pending' : 'sent',
        sent_by: user.id,
      })
      .select()
      .single()

    if (communication.error) return c.json({ error: communication.error.message }, 400)
    return c.json(communication.data)
  })

  app.get('/api/communications', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.query('tenant_id')
    const candidateId = c.req.query('candidate_id')
    const limit = parseInt(c.req.query('limit') || '50')
    const offset = parseInt(c.req.query('offset') || '0')

    if (!tenantId) return c.json({ error: 'tenant_id is required' }, 400)

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    let query = supabase
      .from('communications')
      .select('*', { count: 'exact' })
      .eq('tenant_id', tenantId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1)

    if (candidateId) {
      query = query.eq('candidate_id', candidateId)
    }

    const result = await query
    if (result.error) return c.json({ error: result.error.message }, 400)

    return c.json({
      communications: result.data ?? [],
      total: result.count ?? 0,
    })
  })

  // ==============================================
  // ANALYTICS ENDPOINTS
  // ==============================================

  app.get('/api/recruiting/analytics/funnel', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.query('tenant_id')
    const jobId = c.req.query('job_id')

    if (!tenantId) return c.json({ error: 'tenant_id is required' }, 400)

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    let query = supabase
      .from('applications')
      .select('status, jobs!inner(tenant_id)')
      .eq('jobs.tenant_id', tenantId)

    if (jobId) {
      query = query.eq('job_id', jobId)
    }

    const result = await query
    if (result.error) return c.json({ error: result.error.message }, 400)

    // Count by status
    const funnel = {
      applied: 0,
      screening: 0,
      interview: 0,
      offer: 0,
      hired: 0,
      rejected: 0,
    }

    ;(result.data ?? []).forEach((app: any) => {
      const status = app.status
      if (status in funnel) {
        funnel[status as keyof typeof funnel]++
      }
    })

    return c.json(funnel)
  })

  app.get('/api/recruiting/analytics/sources', async (c) => {
    const supabase = c.get('supabase') as SupabaseClient<Database>
    const tenantId = c.req.query('tenant_id')

    if (!tenantId) return c.json({ error: 'tenant_id is required' }, 400)

    const canRead = await supabase.rpc('app_has_permission', {
      permission: 'recruiting.jobs.read',
      tenant: tenantId,
    })
    if (canRead.error) return c.json({ error: canRead.error.message }, 400)
    if (!canRead.data) return c.json({ error: 'Forbidden' }, 403)

    const result = await supabase
      .from('candidates')
      .select('source, applications(id, status)')
      .eq('tenant_id', tenantId)

    if (result.error) return c.json({ error: result.error.message }, 400)

    // Group by source
    const sources: Record<string, { applications: number; hires: number }> = {}

    ;(result.data ?? []).forEach((candidate: any) => {
      const source = candidate.source
      if (!sources[source]) {
        sources[source] = { applications: 0, hires: 0 }
      }
      sources[source].applications += candidate.applications?.length || 0
      sources[source].hires += candidate.applications?.filter((a: any) => a.status === 'hired').length || 0
    })

    return c.json(sources)
  })
}

